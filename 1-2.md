# 组件化思维

## Web Components 规范

W3C 推出的一套用于**封装具有复用性, 互动性前端组件的技术规范**.

目的: 提供标准的组件化模式.

一个重要的特性: `encapsulation`: keep the markup structure, style, and behavior hedden and separate from other code on the page.

### Custom elements

CutomElementRegistry API:

```js
// Autonomous custom elements: 独立元素

class PopUp extends HTMLElement {
  constructor() {
    super();
    // 定义元素行为...
  }
}

// cutromized built-in elements: 继承了内置元素
class WordCount extends HTMLParagraphElement {
  constructor() {
    super();
    // 定义元素行为...
  }
}
customElements.define("word-count", WordCount, { extends: "p" });
```

参数:
1. 所创建的元素(组件)名称, 遵守DOMString
2. 定义元素行为的类
3. 继承原生元素, 可选.

参考例子: https://github.com/mdn/web-components-examples/blob/master/popup-info-box-web-component/main.js

### Shadow DOM

可以创建一个`sub-DOM tree`, 即一个DOM沙箱, 在HTML的document tree上处于隐藏态, 例如HTML5中的`<video>`, 里面的一系列按钮都是处理隐藏态, 我们不只能看到`<video>`这个Node.

```js
let elementRef = document.createElement('div');
let shadow = elementRef.attachShadow({mode: 'open'}); // open: 代表JS可以通过DOM API获取, close: 无法获取

// custom element
class MyWebComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({mode: 'open'});
  }
  // life cycle hook
  connectedCallback() {
    this.shadowRoot.innerHTML = `
    <p>I'm in the shadow root!</p>
    `
  }
}

window.customElements.define('my-web-component', MyWebComponent)
```

> [对于mode的优势和劣势可以点我](https://blog.revillweb.com/open-vs-closed-shadow-dom-9f3d7427d1af)

### HTML templates

## 小程序组件化

小程序的自定义组件也遵循 Web Components 规范, 采用**Shadow DOM**,
