# 小程序性能

对于一个应用来说, 逻辑的第一诉求是功能实现, 另一方是用户的体验.

- 业务逻辑: 代码最基本的支撑点.
- 用户体验: 
  - 性能: 我们的活, 性能优化
  - 设计: UED的活

> 掌握底层技术帮助我们写出性能更好的代码.

## 如何定位性能问题

性能优化的具体维度:
DOM维度:
1. 避免过大的WXML节点
2. 提早定义图片大小


CSS维度:
1. 降低样式的过分嵌套, 多层嵌套导致CSS规则越复杂, 解析CSSOM时也会带来耗时.
2. 避免频繁操作样式即style, 批量修改Style, 或者通过修改class来应用样式.
3. 对于复杂动画的元素, 使用绝对定位, 脱离文档流, 防止回流.


JS维度:
1. 避免脚本执行时间过长
2. 避免首屏加载时间过长
3. 避免渲染界面时间过长
4. 对网络的请求做必要缓存以及多余的请求
5.  请求耗时不应该太久
6.  避免setData调用频率过大
7.  避免setData的数据过大
8.  避免短时间内请求过多的图片
9.  避免短时间内发起过多的请求

这些优化适用于多端应用, 不仅仅适用于小程序

### 避免过多的DOM节点

渲染流程(只说重点): 
1. [浏览器的渲染引擎(WebKit, Chromium, Gecko)解析HTML文档, 生成DOM树](https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work#%E6%9E%84%E5%BB%BAdom%E6%A0%91).
2. [CSS解释器解析CSS,生成CSSOM].(https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work#%E6%9E%84%E5%BB%BAcssom%E6%A0%91)
3. [DOM树与CSSOM合并进行渲染树](https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work#%E6%B8%B2%E6%9F%93)

DOM树渲染时会占用主线程, 如果渲染时长过长, 会导致浏览器处于用户无法交互的“假死”行为.

DOM节点的控制也会降低VDOM树的结构复杂度.

参考:
[MDN: 浏览器工作原理](https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work)


### 定义图片大小

当生成渲染树后浏览器会将每个节点`paint`到屏幕上时, 可能会发生**回流**(回想一下迟到的图片), 回流会触发重新绘制和重新组合(回流一定会触发重绘, 重绘不会触发回流).

如何解决上述的问题(回流)? 答案就是**我们定义了图像大小, 就不需要重绘, 只需要重绘需要重绘的层.**

### 批量修改样式

和批量执行setData一样, 避免出现DOM的重绘

### 避免脚本执行时间过长

脚本执行分为两个时期:
- 首次渲染时期
- 处理用户的交互时期

不管是小程序执行还是浏览器执行, JS代码执行永远是单线程的,通过任务队列进行管理有效的执行.代码逻辑过于复杂会导致交互出现延迟和卡顿.

### 避免首屏时间太长

影响首屏时间的因素很多: DNS解析耗时, TCP链接的建立耗时等. 
- 代码优化:
  - 降低DOM的复杂度;
  - 渲染数据划分优先级, 核心数据提升渲染优先级, 非核心可以推迟到渲染完后进行.
  - 从设计和交互的角度出发, 展示友好的loading
- 网络优化:
  - 减少网络请求所携带的数据体积
  - 提高服务器处理高并发的能力

### 对请求做出必要的缓存

- 将大量重复的请求结果进行缓存
- 强缓存和协商缓存